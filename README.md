# Trail Runner
## Because boots were too heavy for moving fast.

This demonstration uses JSPM + Automerge-Repo for managing a dynamic loaded-on-demand importMap.

## A Tour

The basic idea here is that we use JSPM to look up what libraries a piece of code uses (app.js), then we calculate the dependencies using a Generator, fetch the dependencies and make them into automerge docs, and last store an importMap pointing to them for future use.

If you run the app with `?shouldRebuild` in the HREF, you'll trigger recompilation of the importMap. Initial setup is slow because I think I've pushed a bunch of junk data into the starting document.

### index.html

This file includes a static importMap generated by the JSPM CLI with a few tweaks to refer to the vendored versions of the JSPM libraries and Automerge, as well as importing `es-module-shims`.

The `es-module-shims` library is a fast polyfill for providing importMap support to browsers that lack it. In our case, we're also taking advantage of its ability to load new importMaps at runtime.

The changes to the JSPM libraries are just to support WASM loading, and the changes to Automerge are to support JSPM. The former, at least, I expect to fixed in the next upstream release.

Aside from creating an environment where we can use JSPM, it also loads `index.js` and `app.js` in that order.

### index.js

This file creates a generator, then looks inside the next file (app.js) to decide what libraries it will need and fetches and inlines them into automerge. (It doesn't do this if it already has an importMap and you haven't asked to regenerate it via the URL.)

### app.js

This is our trivial little pseudo-app. It doesn't do anything but note that we use dynamic imports because static ones don't work. I haven't looked into why yet, because it's late and I'm pleased with my progress so far so I'm calling it a night.

# Next Steps

I'm not entirely sure! We could figure out whether automerge-repo works "inside the box" here as well, then try to implement a simple blutack-like app inside this space. (Or... just port over blutack?)

We should think more about the importMaps and how to compose them / share content-types.

Last, I should probably give Guy (the JSPM author) a tour of this madness and get his input on how to improve it. I expect there are some JSPM features I've misunderstood that could make life easier and this code cleaner, particularly the process of proxying the modules.
